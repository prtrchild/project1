<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Audio Art 3D</title>
    
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdn.jsdelivr.net blob:;
        style-src 'self' 'unsafe-inline';
        img-src 'self' data: blob:;
        media-src 'self' blob:;
        connect-src 'self' https://cdn.jsdelivr.net https://mediapipe.googleapis.com data: blob:;
        object-src 'none';
        base-uri 'self';
    ">

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        #gl-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 99999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #ffae00; font-weight: bold;
        }
        .loader {
            border: 4px solid #333; border-top: 4px solid #ffae00; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #camera-container {
            position: fixed; top: 10px; right: 10px; 
            width: 360px; height: auto;
            z-index: 100; background: #000; border: 1px solid #444; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            resize: both; overflow: hidden; min-width: 240px; max-width: 90vw;
            display: flex; flex-direction: column;
        }
        #camera-header {
            width: 100%; height: 30px; background: #333; cursor: grab;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 10px; box-sizing: border-box;
            color: #aaa; font-size: 13px; user-select: none; flex-shrink: 0;
        }
        .cam-toggle {
            cursor: pointer; font-weight: bold; color: #00ffaa;
            background: #222; padding: 2px 8px; border-radius: 4px; border: 1px solid #444;
        }
        .cam-toggle.off { color: #ff4444; }

        #camera-content { position: relative; width: 100%; height: 100%; flex-grow: 1; background: #000; min-height: 240px; }
        
        /* [ÏàòÏ†ï] ÎÅÑÎ©¥ ÏïÑÏòà Ïïà Î≥¥Ïù¥Í≤å Ï≤òÎ¶¨ÌïòÍ∏∞ ÏúÑÌï¥ Í∏∞Î≥∏ Ïä§ÌÉÄÏùº Ïú†ÏßÄ */
        #input-video { transform: scaleX(-1); display: block; width: 100%; height: 100%; object-fit: cover; opacity: 0.5; }
        #debug-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: fill; }

        #camera-cover {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #enable-btn {
            padding: 10px 20px; border: 1px solid #ffae00; background: transparent;
            color: #ffae00; font-weight: bold; cursor: pointer; border-radius: 4px;
            transition: 0.3s;
        }
        #enable-btn:hover { background: #ffae00; color: #000; }

        #warning-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 9999;
            display: none; 
            align-items: center; justify-content: center;
        }
        #warning-box {
            background: #1a1a1a; padding: 25px; border: 1px solid #555; border-radius: 8px;
            text-align: center; max-width: 300px; color: #fff;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        #warning-title { color: #ff4444; font-size: 18px; margin-bottom: 10px; font-weight: bold; }
        #warning-desc { font-size: 13px; color: #ccc; margin-bottom: 20px; line-height: 1.5; }
        .modal-btn {
            padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; margin: 0 5px;
        }
        #btn-confirm { background: #ff4444; color: white; }
        #btn-cancel { background: #444; color: white; }

        #audio-controls {
            position: fixed; bottom: 20px; left: 20px; z-index: 200;
            background: rgba(0,0,0,0.85); padding: 20px; border-radius: 12px; border: 1px solid #555;
            color: white; display: flex; flex-direction: column; gap: 12px; width: 320px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
        }
        .guide-item { display: flex; justify-content: space-between; border-bottom: 1px solid #444; padding: 6px 0; font-size: 13px; color: #ddd; }
        .guide-item span:first-child { font-weight: bold; color: #ffae00; }
        .audio-status { font-size: 13px; color: #00ffaa; font-weight: bold; margin-top: 5px; text-align: center; }
        
        .lil-gui.root { position: fixed; top: 10px; left: 10px; z-index: 11; }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="loading-overlay" style="display:none;">
        <div class="loader"></div>
        <div>Î°úÎìú Ï§ë . . .</div>
    </div>

    <div id="warning-modal">
        <div id="warning-box">
            <div id="warning-title">‚ö†Ô∏è WARNING</div>
            <div id="warning-desc">
                Ïπ¥Î©îÎùºÎ•º ÌôúÏÑ±ÌôîÌïòÎ©¥ Î≥∏Ïù∏Ïùò ÏòÅÏÉÅÏù¥ ÌôîÎ©¥Ïóê ÌëúÏãúÎê©ÎãàÎã§.<br><br>
                Í≥ÑÏÜç ÌïòÏãúÍ≤†ÏäµÎãàÍπå?
            </div>
            <button id="btn-cancel" class="modal-btn">Ï∑®ÏÜå</button>
            <button id="btn-confirm" class="modal-btn">ÏïåÍ≤†ÏäµÎãàÎã§</button>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://unpkg.com/stats.js@0.17.0/build/stats.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <div id="audio-controls">
        <strong style="color:#b8d6e7; font-size:16px; text-align:center; display:block; margin-bottom:5px;">AUDIO ART FX (by minmaj9)</strong>
        <div class="guide-item">
            <span>üôåüèª Îëê ÏÜêÏùò Í±∞Î¶¨ (Flanger)</span> 
        </div>
        <div class="guide-item">
            <span>‚úäüèª Ïò§Î•∏ÏÜê Ï£ºÎ®π (Filter)</span> 
        </div>
        <div class="guide-item">
            <span>üëåüèª Ïò§Î•∏ÏÜê ÌïÄÏπò (Pan)</span> 
        </div>
        <div class="guide-item">
            <span>‚úãüèª ÏôºÏÜê Ìé¥Í∏∞ (Reverb)</span> 
        </div>
        
        <input type="file" id="audio-file" accept="audio/*" style="margin-top:10px;" />
        <audio id="music-player" controls loop style="width: 100%; display:none; margin-top:5px;"></audio>
        <div id="audio-status" class="audio-status">ÏùåÏïÖ ÌååÏùºÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî</div>
    </div>

    <canvas id="gl-canvas"></canvas>

    <div id="camera-container">
        <div id="camera-header">
            <span>::: ÎìúÎûòÍ∑∏ÌïòÏó¨ Ïù¥Îèô :::</span>
            <div id="cam-toggle-btn" class="cam-toggle">CAM ON</div>
        </div>
        <div id="camera-content">
            <div id="camera-cover">
                <button id="enable-btn">Ïπ¥Î©îÎùº ÌôúÏÑ±Ìôî</button>
            </div>
            <video id="input-video" playsinline></video>
            <canvas id="debug-canvas"></canvas>
        </div>
    </div>

    <script>
        const enableBtn = document.getElementById('enable-btn');
        const modal = document.getElementById('warning-modal');
        const btnConfirm = document.getElementById('btn-confirm');
        const btnCancel = document.getElementById('btn-cancel');
        const cameraCover = document.getElementById('camera-cover');
        const loadingOverlay = document.getElementById('loading-overlay');
        const camToggleBtn = document.getElementById('cam-toggle-btn');
        const inputVideo = document.getElementById('input-video');

        let isCameraActive = true;

        camToggleBtn.addEventListener('click', () => {
            isCameraActive = !isCameraActive;
            if (isCameraActive) {
                camToggleBtn.innerText = "CAM ON";
                camToggleBtn.classList.remove('off');
                inputVideo.style.display = "block"; // Îã§Ïãú Î≥¥Ïù¥Í∏∞
                inputVideo.style.opacity = "0.5";
            } else {
                camToggleBtn.innerText = "CAM OFF";
                camToggleBtn.classList.add('off');
                inputVideo.style.display = "none"; // [ÏàòÏ†ï] ÏïÑÏòà Ïïà Î≥¥Ïù¥Í≤å Ï≤òÎ¶¨
                const cvs = document.getElementById('debug-canvas');
                cvs.getContext('2d').clearRect(0,0,cvs.width,cvs.height);
            }
        });

        enableBtn.addEventListener('click', () => { modal.style.display = 'flex'; });
        btnCancel.addEventListener('click', () => { modal.style.display = 'none'; });
        btnConfirm.addEventListener('click', () => {
            modal.style.display = 'none';
            cameraCover.style.display = 'none';
            loadingOverlay.style.display = 'flex';
            try { initMediaPipe(); } catch(e) { 
                alert("Ïπ¥Î©îÎùº Ïã§Ìñâ Ïã§Ìå®: " + e.message); 
                loadingOverlay.style.display = 'none';
            }
        });

        function startApp() {
            initThree();
            initUI();
            initDraggable();
            animate();
        }

        const AudioEngine = {
            ctx: null, source: null, gainNode: null,
            filterNode: null, pannerNode: null, convolverNode: null, reverbGain: null,
            flangerDelay: null, flangerMix: null, flangerOsc: null,
            analyser: null, dataArray: null,
            isInit: false,

            init(audioElement) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.source = this.ctx.createMediaElementSource(audioElement);
                this.gainNode = this.ctx.createGain();
                
                this.filterNode = this.ctx.createBiquadFilter();
                this.filterNode.type = 'lowpass';
                this.filterNode.frequency.value = 20000; 

                this.pannerNode = this.ctx.createStereoPanner();
                this.pannerNode.pan.value = 0;

                this.convolverNode = this.ctx.createConvolver();
                this.reverbGain = this.ctx.createGain();
                this.reverbGain.gain.value = 0; 
                this.createReverbImpulse(); 

                this.flangerDelay = this.ctx.createDelay();
                this.flangerDelay.delayTime.value = 0.005;
                this.flangerOsc = this.ctx.createOscillator();
                this.flangerOsc.frequency.value = 0.5; 
                const flangerOscGain = this.ctx.createGain();
                flangerOscGain.gain.value = 0.002;
                this.flangerOsc.connect(flangerOscGain);
                flangerOscGain.connect(this.flangerDelay.delayTime);
                this.flangerOsc.start();
                this.flangerMix = this.ctx.createGain();
                this.flangerMix.gain.value = 0;

                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 256; 
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                this.source.connect(this.filterNode);
                this.filterNode.connect(this.pannerNode);
                this.pannerNode.connect(this.gainNode);
                
                this.pannerNode.connect(this.convolverNode); 
                this.convolverNode.connect(this.reverbGain);
                this.reverbGain.connect(this.gainNode);
                
                this.pannerNode.connect(this.flangerDelay);
                this.flangerDelay.connect(this.flangerMix);
                this.flangerMix.connect(this.gainNode);

                this.gainNode.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);

                this.isInit = true;
            },

            createReverbImpulse() {
                const rate = this.ctx.sampleRate;
                const length = rate * 3.0; 
                const impulse = this.ctx.createBuffer(2, length, rate);
                const l = impulse.getChannelData(0); const r = impulse.getChannelData(1);
                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 3.0);
                    l[i] = (Math.random() * 2 - 1) * decay;
                    r[i] = (Math.random() * 2 - 1) * decay;
                }
                this.convolverNode.buffer = impulse;
            },

            update(state) {
                if (!this.isInit) return;
                const t = this.ctx.currentTime;
                const ramp = 0.1;

                const targetFreq = 200 + (20000 - 200) * (1.0 - state.rtTension);
                this.filterNode.frequency.setTargetAtTime(targetFreq, t, ramp);

                const pan = (state.panVal - 0.5) * 2.0; 
                this.pannerNode.pan.setTargetAtTime(pan, t, ramp);

                const reverbAmt = (1.0 - state.ltTension) * 3.0; 
                this.reverbGain.gain.setTargetAtTime(reverbAmt, t, ramp);

                let flangerAmt = 1.0 - (state.handDist / 0.5); 
                flangerAmt = Math.max(0, Math.min(1, flangerAmt)); 
                this.flangerMix.gain.setTargetAtTime(flangerAmt, t, ramp);

                this.analyser.getByteFrequencyData(this.dataArray);
                
                let bassSum = 0;
                for(let i=0; i<10; i++) bassSum += this.dataArray[i];
                const rawBass = (bassSum / 10) / 255.0;
                state.audioBass = rawBass * 2.0; 

                // Snare Detection (2kHz ~ 6kHz)
                let snareSum = 0; let snareCount = 0;
                for(let i=12; i<35; i++) { snareSum += this.dataArray[i]; snareCount++; }
                const rawSnare = (snareSum / snareCount) / 255.0;
                state.audioTreble = Math.max(0, (rawSnare - 0.4) * 3.0); 
            }
        };

        document.getElementById('audio-file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            const player = document.getElementById('music-player');
            const status = document.getElementById('audio-status');
            if (file) {
                player.src = URL.createObjectURL(file);
                player.style.display = 'block';
                status.innerText = "‚ñ∂ Now Playing: " + file.name;
                status.style.color = "#00ffaa";
                if (!AudioEngine.isInit) AudioEngine.init(player);
                player.play().then(() => {
                    if (AudioEngine.ctx.state === 'suspended') AudioEngine.ctx.resume();
                });
            }
        });

        function initDraggable() {
            const container = document.getElementById('camera-container');
            const header = document.getElementById('camera-header');
            let isDragging = false, startX, startY;
            header.addEventListener('mousedown', (e) => {
                if (e.target.id === 'cam-toggle-btn') return;
                isDragging = true; startX = e.clientX; startY = e.clientY;
                const rect = container.getBoundingClientRect();
                container.style.left = rect.left + 'px'; container.style.top = rect.top + 'px';
                container.style.right = 'auto'; container.style.bottom = 'auto';
            });
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - startX; const dy = e.clientY - startY;
                container.style.left = (parseInt(container.style.left||0) + dx) + 'px';
                container.style.top = (parseInt(container.style.top||0) + dy) + 'px';
                startX = e.clientX; startY = e.clientY;
            });
            window.addEventListener('mouseup', () => isDragging = false);
        }

        const CONFIG = {
            maxLines: 200, segments: 50,        
            colorA: '#b8c9f4', colorB: '#bfd260',
            zoom: 0.3  // [ÏàòÏ†ï] Í∏∞Î≥∏ Ï§å 0.3ÏúºÎ°ú Î≥ÄÍ≤Ω
        };

        const STATE = {
            rtTension: 0, ltTension: 1, panVal: 0.5, handDist: 1.0,  
            flangerVal: 0.0, isRtPinching: false, hasCamera: false,
            audioBass: 0.0, audioTreble: 0.0  
        };

        let scene, camera, renderer, lineSegments;
        let simPositions, lineHeads, lineProps;
        let material; 
        
        let initialOpacities;

        function initThree() {
            const canvas = document.getElementById('gl-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            scene = new THREE.Scene(); 
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 80 / CONFIG.zoom; // [ÏàòÏ†ï] Ï¥àÍ∏∞ Ï§å Ï†ÅÏö©
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix(); 
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            createTrails();
        }

        function createTrails() {
            if (lineSegments) {
                scene.remove(lineSegments);
                lineSegments.geometry.dispose();
            }

            const segsPerLine = CONFIG.segments - 1;
            const vertexCount = CONFIG.maxLines * segsPerLine * 2;
            
            const positions = new Float32Array(vertexCount * 3);
            const opacities = new Float32Array(vertexCount);
            const mixAttrib = new Float32Array(vertexCount);
            
            simPositions = new Float32Array(CONFIG.maxLines * CONFIG.segments * 3);
            lineHeads = [];
            lineProps = [];

            initialOpacities = new Float32Array(vertexCount);

            for (let i = 0; i < CONFIG.maxLines; i++) {
                lineHeads.push({ x: 0, y: 0, z: 0 });
                lineProps.push({
                    speed: 0.5 + Math.random() * 0.8,
                    offset: Math.random() * 100,
                    mix: Math.random(),
                    isEscaping: false,
                    vx: 0, vy: 0, vz: 0,
                    life: 1.0,
                    x:0, y:0, z:0
                });

                const lineStartIdx = i * segsPerLine * 2;
                const m = lineProps[i].mix;
                
                for (let s = 0; s < segsPerLine; s++) {
                    const idx = lineStartIdx + s * 2;
                    const alpha1 = 1.0 - (s / segsPerLine);
                    const alpha2 = 1.0 - ((s+1) / segsPerLine);
                    
                    opacities[idx] = alpha1;
                    opacities[idx+1] = alpha2;
                    initialOpacities[idx] = alpha1;
                    initialOpacities[idx+1] = alpha2;

                    mixAttrib[idx] = m;
                    mixAttrib[idx+1] = m;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(opacities, 1));
            geometry.setAttribute('mixFactor', new THREE.BufferAttribute(mixAttrib, 1));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColorA: { value: new THREE.Color(CONFIG.colorA) },
                    uColorB: { value: new THREE.Color(CONFIG.colorB) },
                    uFlanger: { value: 0.0 },
                    uDensityReduction: { value: 0.0 },
                    uAudioTreble: { value: 0.0 }
                },
                vertexShader: `
                    attribute float alpha;
                    attribute float mixFactor;
                    varying float vAlpha;
                    varying vec3 vColor;
                    
                    uniform vec3 uColorA;
                    uniform vec3 uColorB;
                    uniform float uTime;
                    uniform float uFlanger;
                    uniform float uDensityReduction;
                    uniform float uAudioTreble;

                    void main() {
                        vAlpha = alpha * (1.0 - uDensityReduction);
                        vec3 baseColor = mix(uColorA, uColorB, mixFactor);
                        
                        if (uAudioTreble > 0.05) { baseColor += vec3(uAudioTreble); }

                        if (uFlanger > 0.01) {
                            float noise = sin(uTime * 15.0 + mixFactor * 30.0);
                            vec3 glitch = vec3(
                                sin(uTime * 5.0 + mixFactor * 10.0),
                                sin(uTime * 8.0 - mixFactor * 10.0),
                                sin(uTime * 3.0 + mixFactor * 20.0)
                            );
                            baseColor += glitch * uFlanger * 0.8;
                        }
                        vColor = clamp(baseColor, 0.0, 1.0);
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4(vColor, vAlpha);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            lineSegments = new THREE.LineSegments(geometry, material);
            scene.add(lineSegments);
        }

        function updateTrails(time) {
            if (!simPositions || !lineSegments) return;

            const positions = lineSegments.geometry.attributes.position.array;
            const alphaAttrib = lineSegments.geometry.attributes.alpha;
            const opacities = alphaAttrib.array;

            const tension = STATE.rtTension; 
            const panDir = (STATE.panVal - 0.5) * 2.0;
            const flangerVal = Math.max(0, 1.0 - (STATE.handDist / 0.5));
            STATE.flangerVal = flangerVal;
            material.uniforms.uFlanger.value = flangerVal;
            material.uniforms.uDensityReduction.value = tension * 0.5;
            material.uniforms.uAudioTreble.value = STATE.audioTreble; 

            const bassBonus = STATE.audioBass * 30.0; 
            const targetRadius = 45.0 * (1.0 - tension) + 5.0 * tension + bassBonus; 
            const targetAmp = 1.0 * (1.0 - tension * 0.3); 
            
            const reverbAmt = 1.0 - STATE.ltTension;

            for (let i = 0; i < CONFIG.maxLines; i++) {
                const prop = lineProps[i];
                let justReset = false; // [ÏàòÏ†ï] Î¶¨ÏÖã ÌîåÎûòÍ∑∏

                // --- ÌÉàÏ∂ú Î°úÏßÅ ---
                if (prop.isEscaping) {
                    prop.x += prop.vx;
                    prop.y += prop.vy;
                    prop.z += prop.vz;
                    
                    prop.life -= 0.015;
                    if (prop.life <= 0) {
                        // Î¶¨ÏÖã Î∞è Íº¨Î¶¨ ÏûêÎ•¥Í∏∞ ÏòàÏïΩ
                        prop.isEscaping = false;
                        prop.life = 1.0;
                        justReset = true; 
                    }
                }

                // --- Í∂§ÎèÑ ÏúÑÏπò Í≥ÑÏÇ∞ (Î¶¨ÏÖã ÏßÅÌõÑÏóêÎèÑ ÏúÑÏπòÎ•º Ïû°Í∏∞ ÏúÑÌï¥ Ìï≠ÏÉÅ Í≥ÑÏÇ∞ÌïòÍ±∞ÎÇò, Î¶¨ÏÖã Ïãú Í≥ÑÏÇ∞) ---
                if (!prop.isEscaping) {
                    const speed = prop.speed; 
                    const t = time * speed + prop.offset;
                    let ox = (Math.sin(t * 0.9) + Math.cos(t * 1.4));
                    let oy = (Math.cos(t * 0.7) + Math.sin(t * 2.2));
                    let oz = Math.sin(t * 0.5);
                    
                    let wx = Math.sin(t * 2.0 + i) * 2.0;
                    let wy = Math.cos(t * 2.5 + i) * 2.0;
                    let wz = Math.sin(t * 3.0 + i) * 2.0;

                    prop.x = ox * targetRadius + wx * targetAmp;
                    prop.y = oy * targetRadius + wy * targetAmp;
                    prop.z = oz * targetRadius + wz * targetAmp;
                    
                    prop.x += panDir * 45.0;
                    if (Math.abs(panDir) > 0.1) {
                        prop.x += Math.sin(t * 15.0 + prop.y * 0.2) * (panDir * 5.0);
                    }

                    // ÌÉàÏ∂ú Ìä∏Î¶¨Í±∞
                    if (!justReset && reverbAmt > 0.1 && Math.random() < (reverbAmt * 0.05)) {
                        prop.isEscaping = true;
                        prop.life = 1.0;
                        const len = Math.sqrt(prop.x*prop.x + prop.y*prop.y + prop.z*prop.z) + 0.001;
                        const force = 1.5 + Math.random() * 2.0;
                        prop.vx = (prop.x / len) * force;
                        prop.vy = (prop.y / len) * force;
                        prop.vz = (prop.z / len) * force;
                    }
                }

                // --- Trail Update ---
                const segCount = CONFIG.segments;
                const lineStartIdx = i * segCount * 3;
                const alphaStartIdx = i * (segCount - 1) * 2;

                if (justReset) {
                    // [ÏàòÏ†ï] Íº¨Î¶¨ ÏûêÎ•¥Í∏∞: Î™®Îì† ÏÑ∏Í∑∏Î®ºÌä∏Î•º ÌòÑÏû¨ Ìó§Îìú ÏúÑÏπòÎ°ú ÌÜµÏùº
                    for (let k = 0; k < segCount; k++) {
                        const idx = lineStartIdx + k * 3;
                        simPositions[idx] = prop.x;
                        simPositions[idx+1] = prop.y;
                        simPositions[idx+2] = prop.z;
                    }
                } else {
                    // ÏùºÎ∞òÏ†ÅÏù∏ Íº¨Î¶¨ Ïù¥Îèô (Shift)
                    simPositions[lineStartIdx] = prop.x;
                    simPositions[lineStartIdx+1] = prop.y;
                    simPositions[lineStartIdx+2] = prop.z;
                    for (let k = segCount - 1; k > 0; k--) {
                        const c = lineStartIdx + k * 3;
                        const p = lineStartIdx + (k - 1) * 3;
                        simPositions[c] = simPositions[p];
                        simPositions[c+1] = simPositions[p+1];
                        simPositions[c+2] = simPositions[p+2];
                    }
                }

                // BufferGeometry Update
                const rStart = i * (segCount - 1) * 2 * 3;
                for (let k = 0; k < segCount - 1; k++) {
                    const sA = lineStartIdx + k * 3;
                    const sB = lineStartIdx + (k + 1) * 3;
                    const r = rStart + k * 6;
                    
                    positions[r] = simPositions[sA]; positions[r+1] = simPositions[sA+1]; positions[r+2] = simPositions[sA+2];
                    positions[r+3] = simPositions[sB]; positions[r+4] = simPositions[sB+1]; positions[r+5] = simPositions[sB+2];

                    const aIdx = alphaStartIdx + k * 2;
                    opacities[aIdx] = initialOpacities[aIdx] * prop.life;
                    opacities[aIdx+1] = initialOpacities[aIdx+1] * prop.life;
                }
            }
            lineSegments.geometry.attributes.position.needsUpdate = true;
            lineSegments.geometry.attributes.alpha.needsUpdate = true;
        }

        function initUI() {
            const gui = new lil.GUI({ title: 'Settings' });
            
            gui.addColor(CONFIG, 'colorA').name('Color A').onChange(c => {
                if(material) material.uniforms.uColorA.value.set(c);
            });
            gui.addColor(CONFIG, 'colorB').name('Color B').onChange(c => {
                if(material) material.uniforms.uColorB.value.set(c);
            });
            gui.add(CONFIG, 'maxLines', 50, 1000, 50).name('Max Lines').onFinishChange(() => {
                createTrails(); 
            });
            gui.add(CONFIG, 'zoom', 0.1, 3.0).name('Camera Zoom').onChange(v => {
                camera.position.z = 80 / v;
            });
        }

        const videoElement = document.getElementById('input-video');
        const debugCanvas = document.getElementById('debug-canvas');
        const debugCtx = debugCanvas.getContext('2d');
        let handsDetector, lastDetectionTime = 0;

        function initMediaPipe() {
            handsDetector = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            handsDetector.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5 });
            handsDetector.onResults(onHandsResults);
            
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    if (!isCameraActive) return;

                    const now = performance.now();
                    if (now - lastDetectionTime > 35) { 
                        await handsDetector.send({image: videoElement}); 
                        lastDetectionTime = now;
                    }
                }, width: 320, height: 240
            });
            cameraUtils.start().then(() => {
                document.getElementById('loading-overlay').style.display = 'none';
            }).catch(err => {
                console.error(err);
                alert("Camera Access Denied or Error.");
                document.getElementById('loading-overlay').style.display = 'none';
            });
        }

        function onHandsResults(results) {
            debugCanvas.width = videoElement.videoWidth; 
            debugCanvas.height = videoElement.videoHeight;
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                processGestures(results.multiHandLandmarks, results.multiHandedness);
                drawHUD(results.multiHandLandmarks, results.multiHandedness);
            } else {
                STATE.rtTension = lerp(STATE.rtTension, 0, 0.1);
                STATE.ltTension = lerp(STATE.ltTension, 1, 0.1); 
                STATE.isRtPinching = false;
                STATE.panVal = lerp(STATE.panVal, 0.5, 0.1);
            }
        }

        function processGestures(landmarksArray, handednessArray) {
            let leftWrist = null, rightWrist = null;
            let foundR = false, foundL = false;

            for (let i = 0; i < landmarksArray.length; i++) {
                const lm = landmarksArray[i];
                const label = handednessArray[i].label; 

                if (label === 'Left') { // User's Right Hand
                    foundR = true;
                    rightWrist = lm[0];
                    const d = distance(lm[0], lm[12]);
                    const rawTension = map(d, 0.15, 0.45, 1.0, 0.0);
                    STATE.rtTension = lerp(STATE.rtTension, clamp(rawTension, 0, 1), 0.2);

                    const pinchD = distance(lm[4], lm[8]);
                    STATE.isRtPinching = (pinchD < 0.06);
                    if (STATE.isRtPinching) {
                        const visualX = 1.0 - lm[8].x;
                        STATE.panVal = lerp(STATE.panVal, visualX, 0.15);
                    } else {
                        STATE.panVal = lerp(STATE.panVal, 0.5, 0.1); 
                    }
                }
                
                if (label === 'Right') { // User's Left Hand
                    foundL = true;
                    leftWrist = lm[0];
                    const d = distance(lm[0], lm[12]);
                    const rawTension = map(d, 0.15, 0.45, 1.0, 0.0);
                    STATE.ltTension = lerp(STATE.ltTension, clamp(rawTension, 0, 1), 0.2);
                }
            }
            
            if (!foundR) STATE.panVal = lerp(STATE.panVal, 0.5, 0.1);

            if (foundL && foundR) {
                STATE.handDist = lerp(STATE.handDist, distance(leftWrist, rightWrist), 0.1);
            } else {
                STATE.handDist = lerp(STATE.handDist, 1.0, 0.05);
            }
        }

        function drawHUD(landmarksArray, handednessArray) {
            const ctx = debugCtx;
            const w = debugCanvas.width;
            const h = debugCanvas.height;
            const getPos = (pt) => ({x: w * (1-pt.x), y: h * pt.y}); 

            ctx.save();
            ctx.shadowColor = "rgba(0,0,0,0.8)"; ctx.shadowBlur = 4;
            ctx.font = "bold 14px Segoe UI";

            let lPos = null, rPos = null;

            landmarksArray.forEach((lm, i) => {
                const label = handednessArray[i].label;
                const wrist = getPos(lm[0]);

                ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.lineWidth = 1;
                for(const [s,e] of HAND_CONNECTIONS) {
                    const p1 = getPos(lm[s]); const p2 = getPos(lm[e]);
                    ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                }

                if (label === 'Left') { // RIGHT HAND
                    rPos = wrist;
                    const radius = 30 * (1.2 - STATE.rtTension * 0.5);
                    ctx.beginPath(); ctx.arc(wrist.x, wrist.y, radius, 0, Math.PI*2);
                    ctx.strokeStyle = STATE.rtTension > 0.7 ? '#ff0000' : '#ffae00';
                    ctx.lineWidth = 3; ctx.stroke();
                    
                    const filterPct = Math.round(STATE.rtTension * 100);
                    ctx.fillStyle = "#fff"; ctx.fillText(`FILTER: ${filterPct}%`, wrist.x-35, wrist.y-radius-10);

                    if (STATE.isRtPinching) {
                        const centerX = w / 2;
                        const indexTip = getPos(lm[8]); 
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX, 0); ctx.lineTo(centerX, h);
                        ctx.strokeStyle = "rgba(0, 255, 255, 0.3)"; ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX, indexTip.y); ctx.lineTo(indexTip.x, indexTip.y);
                        ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 3; ctx.stroke();
                        
                        ctx.beginPath(); ctx.arc(indexTip.x, indexTip.y, 6, 0, Math.PI*2);
                        ctx.fillStyle = "#00ffff"; ctx.fill();

                        const panVisual = (STATE.panVal - 0.5) * 2.0; 
                        const dir = panVisual < 0 ? 'L' : 'R';
                        const val = Math.round(Math.abs(panVisual) * 100);
                        const labelText = Math.abs(panVisual) < 0.1 ? "CENTER" : `${dir} ${val}%`;

                        ctx.fillStyle = "#00ffff"; 
                        ctx.font = "bold 16px Arial";
                        ctx.fillText(`PAN: ${labelText}`, indexTip.x - 40, indexTip.y + 40);
                    }
                }

                if (label === 'Right') { // LEFT HAND
                    lPos = wrist;
                    const chaos = (1.0 - STATE.ltTension); 
                    ctx.beginPath(); ctx.arc(wrist.x, wrist.y, 25, 0, Math.PI*2);
                    ctx.fillStyle = `rgba(255, 0, 255, ${chaos * 0.5})`; ctx.fill();
                    ctx.strokeStyle = '#ff00ff'; ctx.stroke();
                    
                    const revPct = Math.round(chaos * 100);
                    ctx.fillStyle = "#fff"; ctx.fillText(`ESCAPE: ${revPct}%`, wrist.x-35, wrist.y-40);
                }
            });

            if (lPos && rPos) {
                ctx.beginPath(); ctx.moveTo(lPos.x, lPos.y); ctx.lineTo(rPos.x, rPos.y);
                ctx.strokeStyle = "#ffffff"; ctx.setLineDash([5, 5]); ctx.lineWidth = 2; ctx.stroke();
                ctx.setLineDash([]);

                const cx = (lPos.x + rPos.x) / 2;
                const cy = (lPos.y + rPos.y) / 2;
                const flangerVal = Math.round(STATE.flangerVal * 100);
                
                ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#00ffaa"; ctx.font = "bold 14px Arial";
                ctx.fillText(`FLANGER ${flangerVal}%`, cx - 40, cy - 15);
            }

            ctx.restore();
        }

        function lerp(a,b,t) { return (1-t)*a + t*b; }
        function distance(a,b) { return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); }
        function map(v, iMin, iMax, oMin, oMax) { return oMin + (oMax - oMin) * ((v - iMin) / (iMax - iMin)); }
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            AudioEngine.update(STATE);
            updateTrails(clock.getElapsedTime());
            renderer.render(scene, camera);
        }

        startApp();
    </script>
</body>
</html>
